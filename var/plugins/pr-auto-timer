#!/bin/sh

# pr-auto-timer - automatic timer creation for tuxbox

# Copyright (C) 2012-2013  Patrick Reinhardt, pr-cs <at> reinhardtweb.de
#                    2013  NG-Team
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110, USA

# Related files:
#	Configuration:		/var/tuxbox/config/pr-auto-timer.conf
#	Timer rules:	 	/var/tuxbox/config/pr-auto-timer.rules
#	Neutrino plugin:	/lib/tuxbox/plugins/pr-auto-timer.{so,cfg}

# Todo:
#
#	-show pr-auto-timer as a script plugin in neutrino

# Changelog:
#
# 0.18
#	-add possibility to record all new movies at "Sky Cinema"
#		(in conf-file: SKY_CINEMA="HD|SD|1|24;/alternative/recdir")
#	-support for external rules-file
#		(in conf-file: RULE_FILE_EXT=/path/to/file)
#
# 0.17
#	-accept day groups "Weekday" and "Weekend"
#	-small code optimizations
#	-accept uppercase flags only
#	-Add possible exlusion expressions
#		FOX HD;*;LOST,!Special
#
#	-Support for alternative recording directorys
#		NOTE: flag-section can be empty, but MUST be defined!
#		Sky Cinema HD;*;Ice Age;;/mnt/rec
#
#	-Add possibility to create only the timer for the first show
#		Das Erste HD;*;Tagesschau;F
#		                          ^
#		                          |
#		                          F=Create first timer only.
#
#	-Add possibility to deactivate an entry in rules-file on success (Danke, Patrick!)
#		Sky Cinema HD;*;Ice Age;O
#		             	        ^
#		                        |
#		                        O=Create first timer only and deactivate rule
#
#		NOTE: Define multiple flags by separating them with commas
#		Sky Cinema HD;*;Ice Age;O,Z
#
# 0.16
#	-Whitespace cleanup
#	-Ignore case at search for channel-name and timers
#	-Add timespan-support
#
# ----  NG-Team 		---^
# ----  Patrick Reinhardt 	---v
#
# 0.15
#	-Documentation
#	-Invalid channel names (including those with wrong upper/lower case) now produce a warning message in the log. (Danke, nadine)
#	-Added debugging option DEBUG_DISPLAYLOG
#	-License is now GPLv2
#
# 0.14
#	-License is now GPL
#	-Documentation
#	-Code cleanup & optimizations
#
# 0.13
#	-Updated debugging options
#	-Code optimizations
#	-Fixed special character handling in find_timer, remove_overlapping_timer
#	-Fixed a bug in remove_overlapping_timer
#
# 0.12
#	-EPG data is now acquired using the channel id rather than the channel name as a workaround for a neutrino query string bug. (Danke, tewsbo)
#
# 0.11
#	-Code cleanup & optimizations
#	-Fixed zap timers (Danke, tewsbo)
#	-Default log path changed to /tmp
#	-LOG_FILE can now be overridden in the configuration file (Setting to 'off' disables logging. Default if unset or invalid: /tmp/pr-auto-timer_DATE.log
#	-RULE_FILE can now be overridden in the configuration file. Default if unset or invalid: /var/tuxbox/config/pr-auto-timer.rules
#
# 0.10
#	-Bugfix in the comments :)
#	-Added possibility to add zapto timers.
#		Das Erste HD;Mon;Pinguin;Z
#		                         ^
#		                         |
#		                         Z=Create zap timer instead of record.
#		Backwards compatibility is ensured, i. e. the old format will continue to work
#
# 0.09
#	-Cleaned up unused code
#	-Several bugfixes in the changelog :)
#	-Check if script is already running
#	-Added command line option '--menu'/'-m' which displays a popup in Neutrino
#
# 0.08
#	-Any web server configuration should be supported now. (Danke, vanhofen)
#	-Handle non existing timerd.conf. (Danke, vanhofen)
#	-Timers file (pr-auto-timer.conf) moved to /var/tuxbox/config/pr-auto-timer.rules
#	-Config (MAX_DIFF_MINS) moved to new config file /var/tuxbox/config/pr-auto-timer.conf
#	-Removed warning if log path does not exist
#
# 0.07
#	-Cleaned up unused code
#	-It is now possible to handle whole bouquets rather than single channels
#	-EPG data is now cached
#	-Added a warning message in case the log path does not exist.
#	-Minor optimizations (Danke, vanhofen)
#
# 0.06
#	-Fixed day of week filter (Danke, fred_feuerstein)
#	-RECORD_CORRECTION_MINS removed, recording times now corrected using the values of the tuxbox menu.
#	-Reformatted log.

VERSION=0.18beta
ME=${0##*/}

CONFIG_FILE=/var/tuxbox/config/$ME.conf
PID_FILE=/var/run/$ME.pid

EXIT_SIGNAL=1
EXIT_NO_RULE_FILE=2
EXIT_ALREADY_RUNNING=3

TIMERD_EVENT_TYPE_ZAPTO=3
TIMERD_EVENT_TYPE_RECORD=5

AWK=/bin/awk
CAT=/bin/cat
CUT=/bin/cut
DATE=/bin/date
EGREP=/bin/egrep
GREP=/bin/grep
MKDIR=/bin/mkdir
MKTEMP=/bin/mktemp
MSGBOX=/bin/msgbox
PZAPIT=/bin/pzapit
RM=/bin/rm
SED=/bin/sed
WC=/bin/wc
WGET=/bin/wget

#Debugging options
#Do not remove temporary directory:
DEBUG_TEMP=0
#Do not add or remove any timers:
DEBUG_DRY_RUN=0
#Output display log to STDOUT:
DEBUG_DISPLAYLOG=0

init_config() {
	#Parse config file (default: /var/tuxbox/config/pr-auto-timer.conf)
	if [ -e $CONFIG_FILE ]; then
		source $CONFIG_FILE 2>/dev/null
	fi
	
	case $MAX_DIFF_MINS in
		''|*[!0-9]*) MAX_DIFF_MINS=10 ;;
	esac
	
	if [ ! -d "${LOG_FILE%/*}" ]; then
		case $LOG_FILE in
			[oO][fF][fF])
				LOG_FILE=''
				;;
			*)
				LOG_FILE=/tmp/${ME}_$($DATE +'%F').log
				;;
		esac		
	fi
	max_diff_secs=$(( $MAX_DIFF_MINS \* 60 ))

	if [ ! -e "$RULE_FILE" ]; then
		RULE_FILE=/var/tuxbox/config/$ME.rules
		if [ ! -e "$RULE_FILE" ]; then
			echo "ERROR: Rules file '$RULE_FILE' does not exist! Exiting."
			log "ERROR: Rules file '$RULE_FILE' does not exist! Exiting."
			exit $EXIT_NO_RULE_FILE
		fi
	fi

	# support for external rule-file
	if [ ! -e "$RULE_FILE_EXT" ]; then
		RULE_FILE_EXT=""
	fi

	RULE_FILES="$RULE_FILE $RULE_FILE_EXT"
}

init_displaylog() {
	#Init display log file used for --menu-mode
	displaylogfile=$temp_dir/$ME_display.log
}

init_temp() {
	#Init temporary directory to cache EPG data etc.
	temp_dir=$($MKTEMP -dt $ME.XXXXXX)
	log "\tmain: Temporary directory: '$temp_dir'"
}

init_settings() {
	#Init Tuxbox settings (record/zap extra time)
	record_correction_secs_before=0
	record_correction_secs_after=0
	zap_correction_secs_before=0

	if [ -f /var/tuxbox/config/timerd.conf ]; then
		record_correction_secs_before=$($EGREP EXTRA_TIME_START /var/tuxbox/config/timerd.conf | $CUT -d'=' -f2)
		record_correction_secs_after=$($EGREP EXTRA_TIME_END /var/tuxbox/config/timerd.conf | $CUT -d'=' -f2)
	fi

	if [ -f /var/tuxbox/config/neutrino.conf ]; then
		zap_correction_secs_before=$(( $($EGREP zapto_pre_time /var/tuxbox/config/neutrino.conf | $CUT -d'=' -f2) * 60 ))
	fi
	
	log "\t\tinit_settings: record_correction_secs_before: $record_correction_secs_before, record_correction_secs_after: $record_correction_secs_after, zap_correction_secs_before: $zap_correction_secs_before"
}

init_webserver() {
	#Build web server URL for API access including authentication
	#returns: web server base URL, e. g. http://user:pass@localhost
	webserver_url=$($AWK '
		BEGIN				{ FS="=" }
		/^WebsiteMain.port/		{ port=$2 }
		/^mod_auth.authenticate=/	{ auth=$2 }
		/^mod_auth.username=/		{ username=$2 }
		/^mod_auth.password=/		{ password=$2 }
		END	{
			if ( auth == "true" ) {
				printf("http://%s:%s@localhost:%i\n", username, password, port);
			} else {
				printf("http://localhost:%i\n", port);
			}
		}
	' /var/tuxbox/config/nhttpd.conf)
}

begin_ifs_block() {
	#Backup IFS (input field separator) to restore it after parsing arguments
	IFS_SAVE=$IFS
	set -f
}

end_ifs_block() {
	#Restore (input field separator) IFS after parsing arguments
	IFS=$IFS_SAVE
	set +f
}

url_encode() {
	#http://rosettacode.org/wiki/URL_encoding#AWK
	echo $*|$AWK '
		BEGIN {
			for (i = 0; i <= 255; i++)
				ord[sprintf("%c", i)] = i
		}

		function escape(str, c, len, res) {
			len = length(str)
			res = ""
			for (i = 1; i <= len; i++) {
				c = substr(str, i, 1);
				if (c ~ /[0-9A-Za-z]/)
					res = res c
				else
					res = res "%" sprintf("%02X", ord[c])
			}
			return res
		}

		{ print escape($0) }
	'
}

parse_options() {
	#Parse pr-auto-timer command line arguments
	if [ $# -gt 0 ]; then
		case $1 in
			-m|--menu)
				opt_menu=true
				;;
		esac
	fi
}

parse_xregex() {
	#Parse possible exclusion regex
	if [ ${#xregex} -le 1 ]; then
		xregex=""
	elif [ X${xregex:0:1} = X! ]; then	# tricking shell with an uppercase X
		xregex=${xregex:1}		# to avoid interpreting ! as an operator
	else
		xregex=""
	fi
}

parse_timespan() {
	#Parse possible timespan
	timespan="$1"

	if [ "$timespan" = "" ]; then
		timespan="*"
		return
	fi

	#split timespan
	begin_ifs_block
		IFS='-'
		set -- $timespan
		timespan_start=$1
		timespan_stop=$2
	end_ifs_block

	#split timespan_start
	begin_ifs_block
		IFS=':'
		set -- $timespan_start
		timespan_start_h=$1
		timespan_start_m=$2
	end_ifs_block

	#split timespan_stop
	begin_ifs_block
		IFS=':'
		set -- $timespan_stop
		timespan_stop_h=$1
		timespan_stop_m=$2
	end_ifs_block

	e=0
	#check format hh:mm
	echo $timespan_start | $GREP -q '^[0-9][0-9]:[0-9][0-9]'
		e=$(($e+$?))
	echo $timespan_stop | $GREP -q '^[0-9][0-9]:[0-9][0-9]'
		e=$(($e+$?))
	#check hours
	if [ "$timespan_start_h" -gt "23" -o "$timespan_stop_h" -gt "23" ]; then
		e=$(($e+1))
	fi
	#check minutes
	if [ "$timespan_start_m" -gt "59" -o "$timespan_stop_m" -gt "59" ]; then
		e=$(($e+1))
	fi
	#finally we use the date-command to check the full string
	$DATE -d $timespan_start +%s 2>/dev/null 1>/dev/null
		e=$(($e+$?))
	$DATE -d $timespan_stop +%s 2>/dev/null 1>/dev/null
		e=$(($e+$?))

	if [ $e -ne 0 ]; then
		log "\tparse_timespan: Error while checking! timespan disabled!"
		timespan="*"
	else
		timespan_start_s=$($DATE -d $timespan_start +%s)
		timespan_stop_s=$($DATE -d $timespan_stop +%s)
		if [ $timespan_start_s -gt $timespan_stop_s ]; then
			timespan_over_midnight=true
		else
			timespan_over_midnight=false
		fi
	fi
}

parse_flags() {
	#Parse flags of entrys in rule file
	event_type=$TIMERD_EVENT_TYPE_RECORD
	first_match=false
	only_once=false
	case $1 in
		Z|*,Z|Z,*|*,Z,*)
			event_type=$TIMERD_EVENT_TYPE_ZAPTO
		;;
	esac
	case $1 in
		R|*,R|R,*|*,R,*)
			event_type=$TIMERD_EVENT_TYPE_RECORD
		;;
	esac
	case $1 in
		F|*,F|F,*|*,F,*)
			first_match=true
		;;
	esac
	case $1 in
		O|*,O|O,*|*,O,*)
			only_once=true
			first_match=true
		;;
	esac
}

parse_recdir() {
	#Parse recording directory
	if [ $event_type = $TIMERD_EVENT_TYPE_ZAPTO ]; then
		recdir=""
	else
		recdir=$(url_encode "$recdir")
	fi
}

parse_dowgroup() {
	#Check for weekday or weekend and set var dowgroup
	dowgroup=$(echo $dowfilter | $AWK '{print tolower($0)}')
	if [ "$dowgroup" = "weekday" -o "$dowgroup" = "weekend" ]; then
		case $dow in
			Mon|Tue|Wed|Thu|Fri)
				if [ "$dowgroup" = "weekday" ]; then
					dowgroup=true
				fi
			;;
			Sat|Sun)
				if [ "$dowgroup" = "weekend" ]; then
					dowgroup=true
				fi
			;;
		esac
	fi
}

parse_sky_cinema() {
	if [ "$SKY_CINEMA" = "" ]; then
		sky_cinema=""
		return
	fi

	# split $SKY_CINEMA
	begin_ifs_block
		IFS=';'
		set -- $SKY_CINEMA
		sky_cinema=$1
		recdir=$2
	end_ifs_block

	_start_sec_add=0

	case $(echo $sky_cinema | $AWK '{print toupper($0)}') in
		SD)
			sky_cinema="Sky Cinema"
		;;
		HD)
			sky_cinema="Sky Cinema HD"
		;;
		1)
			sky_cinema="Sky Cinema +1"
			_start_sec_add=$((60 \* 60))
		;;
		24)
			sky_cinema="Sky Cinema +24"
			_start_sec_add=$((60 \* 60 \* 24))
		;;
		*)
			sky_cinema=""
		;;
	esac
}

log() {
	#Log message to log file
	#$*: Log message
	if [ "$LOG_FILE" != "" ]; then
		echo -e $($DATE +'%F %H:%M:%S') [$$]: "$*" >> $LOG_FILE
	fi
}

displaylog() {
	#Log message to display log (--menu-mode)
	#$*: Log message
	if [ $opt_menu ]; then
		echo -e "$@" >> $displaylogfile
	fi
}

get_channel_id_by_channel_name() {
	#$1: channel name (ignore case)
	#returns: id of the first(!) matching channel
	temp_file="$temp_dir/channellist"
	if [ ! -e "$temp_file" ]; then
		$WGET -qO "$temp_file" "$webserver_url/control/channellist"
	fi
	$AWK -v channel="$1" '
		/^[0-9a-f]{16} / {
			if (tolower($0) == tolower($1 " " channel)) {
				print $1;
				exit 0;
			}
		}
	' $temp_file
	#Nooooooooooooo! This wouldn't have been necessary if query string handling worked in Neutrino...
}

get_channel_xml() {
	#Fetch EPG data in XML for a specified channel.
	#$1: channel name
	#returns: XML EPG data
	channel_id=$(get_channel_id_by_channel_name "$1")
	if [ "$channel_id" != "" ]; then
		temp_file="$temp_dir/$channel_id"
		if [ ! -e "$temp_file" ]; then
			$WGET -qO "$temp_file" "$webserver_url/control/epg?xml=true&channelid=$channel_id"
		fi
		$CAT "$temp_file"
	else
		log "\t\tget_channel_xml: !!! WARNING: Channel '$1' was NOT found. Skipping !!!"
	fi
}

get_corrected_start_stop_times() {
	#Calculate corrected start/stop times using the tuxbox vaules (EXTRA_ etc.)
	#$1: start secs
	#$2: stop secs
	#$3: timerd event type
	#returns: $start_sec_corrected $stop_sec_corrected
	if [ $3 = $TIMERD_EVENT_TYPE_ZAPTO ]; then
		start_sec_corrected=$(( $1 - $zap_correction_secs_before )) 
		stop_sec_corrected=0
	else
		start_sec_corrected=$(( $1 - $record_correction_secs_before )) 
		stop_sec_corrected=$(( $2 + $record_correction_secs_after ))
	fi
	echo $start_sec_corrected $stop_sec_corrected
}

get_sky_moviedata() {
	data_file=/tmp/sky_moviedata
	if [ -e $data_file ]; then
		if [ $(($($DATE +%s)\-$($DATE -r $data_file +%s))) -gt 86400 ]; then
			rm -f $data_file
		fi
	fi
	if [ ! -e $data_file ]; then
		$WGET -qO "$data_file" "http://www.moviepilot.de/liste/sky-neustarts-filmschauer"
	fi
	$CAT $data_file | $AWK '
		BEGIN {
			false=0;
			found=false;
		}
		END {
		}

		/board_item_description/ {
			found="date";
			date="";
			next;
		}

		/clearfix/ {
			found=false;
			next;
		}

		/<h3>/ {
			found="movie";
			movie="";
			next;
		}

		/<\/h3>/ {
			found=false;
			next;
		}

		/<span>|\/serie\// {
			next;
		}

		// {
			if ( found == "date" ) {
				gsub (/\,/, " ");
				gsub (/\./, " ");
				gsub ("Montag"	, "Mon");
				gsub ("Dienstag", "Tue");
				gsub ("Mittwoch", "Wed");
				gsub ("Donnerstag", "Thu");
				gsub ("Freitag"	, "Fri");
				gsub ("Samstag"	, "Sat");
				gsub ("Sonntag"	, "Sun");
				gsub ("Januar"	, "1");
				gsub ("Februar"	, "2");
				gsub ("MÃ¤rz"	, "3");
				gsub ("April"	, "4");
				gsub ("Mai"	, "5");
				gsub ("Juni"	, "6");
				gsub ("Juli"	, "7");
				gsub ("August"	, "8");
				gsub ("September", "9");
				gsub ("Oktober"	, "10");
				gsub ("November", "11");
				gsub ("Dezember", "12");

				date=$1 "|" $3 "." $2 "-" $4;
			}
			if ( found == "movie" ) {
				gsub (/<\/a.*>/, "");
				gsub (/<a.*>/, "");
				gsub (/^[[:space:]]*/, "");
				gsub (/&#x27;/, "'\''");

				movie=$0;
				printf("%s|%s\n", date, movie);
			}
			next;
		}

		// {
			found=false;
			next;
		}
	'
}

find_show() {
	#Find a show by (exact) channel name or bouquet number and RegEx(!) for show name.
	#$1: channel
	#$2: show name regex
	#$3: exclude regex
	#returns: list of found shows in the format 'CHANNEL_ID|START_SEC|STOP_SEC|CHANNEL_NAME|DESCRIPTION'
	case $1 in
		\**|\*)
			if [ "$1" = "*" ]; then
				bouquet=1
			else
				bouquet=$(echo $1 | $AWK '{print substr($0,2)}')
			fi
			log "\t\tfind_show: Bouquet: $bouquet"
			channels=$($PZAPIT $bouquet|$AWK '
				/^[[:space:]]*[[:digit:]]+:[[:space:]]+[^(]*[[:space:]]+\([[:xdigit:]]+\)$/ {
					gsub("(^[[:space:]]*[[:digit:]]+:[[:space:]]+|[[:space:]]+\\([[:xdigit:]]+\\)$)","");
					print
				}
			')
			echo -e "$channels" | while read channel; do
				find_show_by_channel "$channel" "$2"
			done
			;;
		*)
			find_show_by_channel "$1" "$2" "$3"
			;;
	esac
}

find_show_by_channel() {
	#Find a show by (exact) channel name and RegEx(!) for show name.
	#$1: channel name
	#$2: show name regex
	#$3: exclude regex
	#returns: list of found shows in the format 'CHANNEL_ID|START_SEC|STOP_SEC|CHANNEL_NAME|DESCRIPTION'
	xml=$(get_channel_xml "$1")
	result=$(echo -ne "$xml"|$AWK '
		BEGIN							{ matches=0; }
		END							{ exit (matches == 0); }
		/<channel_id>[0-9a-z]+<\/channel_id>/			{ channel_id	= gensub(/<\/?[^>]+>/, "", "g"); }
		/<start_sec>[0-9]+<\/start_sec>/			{ start_sec	= gensub(/<\/?[^>]+>/, "", "g"); }
		/<stop_sec>[0-9]+<\/stop_sec>/				{ stop_sec	= gensub(/<\/?[^>]+>/, "", "g"); }
		/<description><!\[CDATA\[.*\]\]><\/description>/	{ description	= gensub(/(<description><!\[CDATA\[|\]\]><\/description>)/, "", "g"); }
		/<prog>/	{
			channel_id	= "";
			start_sec	= "";
			stop_sec	= "";
			description	= "";
		}
		/<\/prog>/ 	{
			if (match(description, show_regex)) {
				if ( (exclude_regex == "") || (!(match(description, exclude_regex))) ) {
					matches++;
					printf("%s|%i|%i|%s|%s\n", channel_id, start_sec, stop_sec, channel_name, description);
				}
			}
		}
	' exclude_regex="$3" show_regex="$2" channel_name="$1")

	if [ $? -eq 0 ]; then
		matches=$(echo "$result"|$WC -l)
		log "\t\tfind_show_by_channel: Found $matches matches for regex '$2' (excl. '$3') on channel '$1'."
		echo -e "$result"
		return 0
	else
		log "\t\tfind_show_by_channel: Found NO matches for regex '$2' (excl. '$3') on channel '$1'."
		return 1
	fi
}

find_show_by_start_sec() {
	#Find a show by (exact) channel name and start time.
	#$1: channel name
	#$2: start time in seconds
	#returns: list of found shows in the format 'CHANNEL_ID|START_SEC|STOP_SEC'
	xml=$(get_channel_xml "$1")
	result=$(echo -ne "$xml"|$AWK -v __start_sec="$2" '
		BEGIN							{ matches=0 }
		END							{ exit (matches == 0); }
		/<channel_id>[0-9a-z]+<\/channel_id>/			{ channel_id	= gensub(/<\/?[^>]+>/, "", "g"); }
		/<start_sec>[0-9]+<\/start_sec>/			{ start_sec	= gensub(/<\/?[^>]+>/, "", "g"); }
		/<stop_sec>[0-9]+<\/stop_sec>/				{ stop_sec	= gensub(/<\/?[^>]+>/, "", "g"); }
		/<prog>/	{
			channel_id	= "";
			start_sec	= "";
			stop_sec	= "";
		}
		/<\/prog>/ 	{
			if (__start_sec == start_sec) {
				matches=1;
				printf("%s|%i|%i\n", channel_id, start_sec, stop_sec);
			}
		}
	')

	if [ $? -eq 0 ]; then
		log "\t\tfind_show_by_start_sec: Found match for start time '$2' on channel '$1'."
		echo -e "$result"
		return 0
	fi
}

find_timer() {
	#Find an (exact) existing timer using channel name, alarm time, stop time and event type
	#$1: channel name (ignore case)
	#$2: alarm time
	#$3: stop time
	#$4: event type (5: record, 3: zapto)
	#Note: find_timer ignores repeated timers
	$WGET -qO - "$webserver_url/control/timer" | $AWK -v pattern="# $4 0 0 # $2 $3 $1" '
		BEGIN { returncode=1 }
		{$1=$5="#";if(tolower($0)==tolower(pattern)) returncode=0}
		END {exit returncode}
	'
}

prevent_timer_by_timespan() {
	#$1: alarm time
	if [ "$timespan" = "*" ]; then
		return 1 # don't prevent
	fi

	timer_start_h=$(($(echo $($DATE -d @${1} +%H) | $SED 's/^0//') * 60 * 60))
	timer_start_m=$(($(echo $($DATE -d @${1} +%M) | $SED 's/^0//') * 60))
	timer_start=$((${timer_start_h} + ${timer_start_m}))

	timespan_from_h=$(($(echo ${timespan_start_h} | $SED 's/^0//') * 60 * 60))
	timespan_from_m=$(($(echo ${timespan_start_m} | $SED 's/^0//') * 60))
	timespan_from=$((${timespan_from_h} + ${timespan_from_m}))

	timespan_till_h=$(($(echo ${timespan_stop_h} | $SED 's/^0//') * 60 * 60))
	timespan_till_m=$(($(echo ${timespan_stop_m} | $SED 's/^0//') * 60))
	timespan_till=$((${timespan_till_h} + ${timespan_till_m}))

	ret=1
	if [ "$timespan_over_midnight" = "false" ]; then
		if ! [ $timer_start -ge $timespan_from -a $timer_start -le $timespan_till ]; then
			# timer doesn't start inside timespan
			ret=0 # prevent
		fi
	else
		if [ $timer_start -gt $timespan_till -a $timer_start -lt $timespan_from ]; then
			# timer starts outside timespan
			ret=0 # prevent
		fi
	fi
	return $ret
}

remove_overlapping_timer() {
	#Find and remove overlapping/similar timers resulting from changed EPG data
	#$1: channel name (ignore case)
	#$2: alarm time
	#$3: timerd event type
	#returns: API result (hopefully: 'ok')
	#Note: remove_overlapping_timer ignores repeated timers
	alarm_time=$2
	$WGET -qO - "$webserver_url/control/timer" | $AWK -v pattern="# $3 0 0 # # # $1" '{
		timer_id=$1;
		tstart_sec=$6;
		$1=$5=$6=$7="#";
		if(tolower($0)==tolower(pattern)) print timer_id " " tstart_sec
	}' | while read timer; do
		begin_ifs_block
			IFS=' '
			set -- $timer
			timer_id=$1
			tstart_sec=$2
		end_ifs_block
		
		if [ $alarm_time -gt $tstart_sec ]; then
			diff_secs=$(( $alarm_time - $tstart_sec ))
		else
			diff_secs=$(( $tstart_sec - $alarm_time ))
		fi
		if [ $diff_secs -le $max_diff_secs ]; then
			if [ $DEBUG_DRY_RUN == 0 ]; then
				result=$($WGET -qO - "$webserver_url/control/timer?action=remove&id=$timer_id")
			else
				result="DISABLED: DEBUG_DRY_RUN"
			fi
			log "\t\tremove_overlapping_timer: Timer id: $timer_id overlaps by $diff_secs seconds (max: $max_diff_secs). Removing: $result"
		fi
	done
}

add_timer() {
	#Add a timer using channel name, channel id, alarm time, stop time and event type if it does not already exist. Overlapping timers are removed before.
	#$1: channel name
	#$2: channel id
	#$3: alarm time
	#$4: stop time
	#$5: timerd event type
	#$6: alt rec dir
	#Note: Announce time is ignored.
	if [ "$first_match" = "done" ]; then
		return
	fi
	if find_timer "$1" $3 $4 $5; then
		log "\t\tadd_timer: Identical timer '$1' $3 $4 $5 already exists. Skipping."
	elif prevent_timer_by_timespan $3; then
		log "\t\tadd_timer: Preventing timer '$1' $3 ($($DATE -d @${3} +"%H:%M")) by timespan ($timespan). Skipping."
	else
		remove_overlapping_timer "$1" $3 $5
		if [ $DEBUG_DRY_RUN == 0 ]; then
			result=$($WGET -qO - "$webserver_url/control/timer?action=new&type=$5&alarm=$3&stop=$4&channel_id=$2&rec_dir=$6")
		else
			result="DISABLED: DEBUG_DRY_RUN"
		fi
		log "\t\tadd_timer: Adding timer '$1' $3 $4 $5: $result."
		if [ "$first_match" = "true" ]; then
			log "\t\tadd_timer: Ignoring possible following shows on '$1'."
			first_match=done;
		fi
	fi
}

signal_handler() {
	#Handle INT, TERM signals and clean up.
	log "Caught signal. Cleaning up."
	cleanup
	set +f
	log "done."
	exit $EXIT_SIGNAL
}

cleanup() {
	#Remove temporary directory and PID file.
	if [ $DEBUG_TEMP == 0 ]; then
		log "\tcleanup: Removing directory '$temp_dir'..."
		$RM -rf $temp_dir 2>/dev/null
	fi
	$RM -rf $PID_FILE 2>/dev/null
}

trap signal_handler INT TERM

if [ -e $PID_FILE ]; then
	log "$ME ist already running. Exiting..."
	exit $EXIT_ALREADY_RUNNING
else
	echo $$ > $PID_FILE
fi

init_config

log "$ME V$VERSION started."
if [ $DEBUG_TEMP == 1 ]; then
	log "\tmain: !!! WARNING: DEBUG_TEMP is enabled. Temporary files will not be removed !!!"
fi
if [ $DEBUG_DRY_RUN == 1 ]; then
	log "\tmain: !!! WARNING: DEBUG_DRY_RUN is enabled. Timers will not be modified !!!"
fi

init_settings
init_temp
init_webserver
init_displaylog
parse_options $@

if [ $opt_menu ]; then
	$MSGBOX title="Auto Timer" size=20 timeout=5 refresh=0 cyclic=0 popup="Running..." >/dev/null
fi

for rule_file in $RULE_FILES; do
	log "\tmain: processing '${rule_file}'"
	rule_line=0
	$CAT $rule_file | \
while read line ;do
	rule_line=$((${rule_line}+1))
	if echo $line | $EGREP -q '^[[:space:]]*([^#;]+);+([^;]+);+([^;]+);?([^;/]+)?;?([^;]+)?;?$'; then
		# split config line
		begin_ifs_block
			IFS=';'
			set -- $line
			channelname=$1
			dowfilter=$2
			regex=$3
			flags=$4
			recdir=$5
		end_ifs_block

		# split dowfilter
		begin_ifs_block
			IFS=','
			set -- $dowfilter
			dowfilter=$1
			timespan=$2
		end_ifs_block

		# split regex
		begin_ifs_block
			IFS=','
			set -- $regex
			regex=$1
			xregex=$2
		end_ifs_block

		parse_xregex

		parse_timespan "$timespan"

		parse_flags "$flags"

		parse_recdir

		log "\tmain: channel: '$channelname', dow: '$dowfilter', timespan: '$timespan', regex: '$regex', xregex: '${xregex:-none}', event type: '$event_type', flags: '${flags:-none}', rec dir: '${recdir:-std::neutrino}'"

		shows=$(find_show "$channelname" "$regex" "$xregex")
		shows_found=0

 		echo -e "$shows" | {
			while read result; do
				if [ "$result" = "" ]; then
					break
				fi
				shows_found=$(( $shows_found + 1 ))

				begin_ifs_block
					IFS='|'
					set -- $result
					channelid=$1
					start_sec=$2
					stop_sec=$3
					channelname=$4
					description=$5
				end_ifs_block
	
				set -- $(get_corrected_start_stop_times $start_sec $stop_sec $event_type)
				start_sec_corrected=$1
				stop_sec_corrected=$2

				dow=$($DATE -d @${start_sec} +%a)

				parse_dowgroup
	
				log "\t\tmain: description: '$description', channelname: '$channelname', channelid: $channelid"
				log "\t\tdow: $dow, start_sec: $start_sec, start_sec_corrected: $start_sec_corrected, stop_sec: $stop_sec, stop_sec_corrected: $stop_sec_corrected"
	
				if [ $start_sec_corrected -gt $($DATE +%s) ]; then
					if [ "$dow" = "$dowfilter" -o "$dowfilter" = "*" -o "$dowgroup" = "true" ]; then
						add_timer "$channelname" $channelid $start_sec_corrected $stop_sec_corrected $event_type $recdir
						if [ "$first_match" = "done" ]; then
							if [ "$only_once" = "true" ]; then
								log "\t\tmain: Deactivating entry in rules-file as requested."
								$SED -i "${rule_line} s/^/#/g" ${rule_file}
							fi
							break
						fi
					else
						log "\t\tmain: NOT adding timer because of non-matching weekday."
					fi
				else
					log "\t\tmain: NOT adding timer because start_secs lies in the past."
				fi
			done
			displaylog "~T0150 $channelname ~T0300 $dowfilter ~T0350 $regex ~T0900 $shows_found Treffer"
		}
	fi
done # while loop
done # for loop

parse_sky_cinema

if [ ! "$sky_cinema" = "" ]; then
	log "\tmain: processing new movies at \"$sky_cinema\""

	parse_timespan	# reset timespan
	parse_flags	# reset flags

	parse_recdir

	sky_moviedata=$(get_sky_moviedata)

	echo "$sky_moviedata" | while read line; do
		_date=$(echo $line | cut -d"|" -f2 | sed 's/^ *//g;s/ *$//g;')
		_movie=$(echo $line | cut -d"|" -f3 | sed 's/^ *//g;s/ *$//g;')
		if _start_sec=$($DATE -d "$_date" +%s 2>/dev/null); then
			_start_sec=$((_start_sec \+ _start_sec_add))
			_show_data=$(find_show_by_start_sec "$sky_cinema" "$_start_sec")
			if [ ! "$_show_data" = "" ]; then
				# split _show_data
				begin_ifs_block
					IFS='|'
					set -- $_show_data
					channelid=$1
					start_sec=$2
					stop_sec=$3
				end_ifs_block

				set -- $(get_corrected_start_stop_times $start_sec $stop_sec $event_type)
				start_sec_corrected=$1
				stop_sec_corrected=$2

				add_timer "$sky_cinema" $channelid $start_sec_corrected $stop_sec_corrected $event_type $recdir
			fi
		fi
	done
fi

if [ $opt_menu ]; then
	$MSGBOX title="Auto Timer" size=20 refresh=0 cyclic=0 timeout=15 popup=$displaylogfile >/dev/null
	if [ $DEBUG_DISPLAYLOG == 1 ]; then
		$CAT $displaylogfile
	fi
fi

cleanup

log "done."
